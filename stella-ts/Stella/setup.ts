// TypeScript File generated by the BNF Converter (bnfc 2.9.6).

import {CharStream, CommonTokenStream, ErrorListener, FileStream, RecognitionException, Recognizer} from 'antlr4'
import StellaGrammarLexer from './StellaLexer'
import StellaGrammarParser from './StellaParser'
import {buildProgram} from './builder'
import fs from 'fs'
import path from 'path'
import * as readline from 'readline/promises'
import {Typechecker} from './typecheck'

class StellaErrorListener<T> extends ErrorListener<T> {
  constructor() {
    super()
  }

  syntaxError(
    _recognizer: Recognizer<T>,
    _offendingSymbol: T,
    _line: number,
    _column: number,
    _msg: string,
    e: RecognitionException | undefined
  ) {
    process.exit()
  }
}

async function getInput() {
  const filename = process.argv[2]
  if (filename) {
    const fullPath = path.resolve(filename)
    if (!fs.existsSync(fullPath)) {
      console.log(`file ${fullPath} does not exist`)
      process.exit()
    }
    return new FileStream(fullPath)
  } else {
    const rl = readline.createInterface(process.stdin, process.stdout)
    const inputPromise = new Promise<string>((resolve) => {
      let input = ''
      rl.on('line', (data) => {
        input += data
      }).on('close', () => {
        resolve(input)
      })
    })
    const input = await inputPromise
    return new CharStream(input)
  }
}

function createParser(charStream: CharStream) {
  const lexer = new StellaGrammarLexer(charStream)
  lexer.addErrorListener(new StellaErrorListener())
  const tokenStream = new CommonTokenStream(lexer)
  const parser = new StellaGrammarParser(tokenStream)
  parser.addErrorListener(new StellaErrorListener())
  return parser
}

export async function main() {
  const input = await getInput()
  const parser = createParser(input)
  const ast = buildProgram(parser.program())
  const typechecker = new Typechecker()
  typechecker.typecheck(ast)
}
